<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>dimpoc presentation</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@4.5.0/dist/reveal.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@4.5.0/dist/theme/solarized.css" id="theme">
  <style>
    /* Small tweaks */
    .reveal .slides section { font-size: 28px; }
    pre code { font-size: 0.7em; }
  </style>
</head>
<body>
  <div class="reveal">
    <div class="slides" id="slides">
      <!-- Slides will be injected here -->
       <p>Press the > image in the lower right to start
        the slide show.
       </p>
    </div>
  </div>

  <!-- Embedded markdown source -->
  <script id="md-source" type="text/plain">
---
title: dimpoc POC — Semantic Sanitization & Validation
author: Security Engineering / Data Safety
date: November 2025
---

# dimpoc — Data Sanitization POC

**Goal:** Demonstrate annotation-driven sanitization and validation of C# string fields to reduce injection/XSS risk and make data safe for downstream processing.

_Speaker note:_ Quick intro / 30s explanation of why field-level sanitization is useful beyond request-parameter validators.  Mention zero trust and
need for validation when data crosses trust boundary.

---

## Problem Statement

- Our scanners found many data injection/XSS vulnerabilities.
- XSS has > 30,000 CVEs; SQL injection > 14,000 CVEs
- Validation libraries often operate only on HTTP request parameters, not object fields.
- Attack payloads may come from DBs, files, or external systems.
- Should validate whenever data crosses a trust boundary.

_Speaker note:_ Emphasize risk, exposure, and remediation backlog.  Common Vulnerabilities and Exposures (CVE) - catalog entry for a bug that could be exploited—used by developers, security teams, and attackers.  AI can code an exploit from the CVE.

---

## Our Approach (POC)

- Use C# annotations on string fields to encode *semantic types* (e.g., `TIN`, `PAN`, `Tel`, `USNUM`).
- Semantic library finds annotated fields and applies per-type handlers:
  - `Sanitize(object)` — strips attack characters and normalizes values
  - `Validate(object)` — lightweight checks (Luhn for PAN, length checks for TIN/Tel, numeric parse for USNUM)
- Returns `FieldResults` with per-field `FieldResultItem` entries: name, empty, valid

_Speaker note:_ This is low-friction for devs — annotate fields once, get consistent behavior across sources.  We will disribute updates for new data types and new masking rules.  When will EU require masking phones?

---

## Demo Summary (what we show today)

- Example object with annotated fields containing valid and attack-laden values
- Run `Sanitize(demo)` → fields are cleaned and nulls converted to empty
- Run `Validate(demo)` → lightweight validation (Luhn check, phone normalization)
- Output shows which fields changed (sanitized) and which validated OK

_Placeholder:_ add screenshot(s) of console output here: `docs/screenshots/sanitize-validate.png`

---

## Technical notes (for engineers)

- Implemented as a .NET 9 console project `dimpoc`
- Core files:
  - `Attributes.cs` — attribute types (`TIN`, `PAN`, `Tel`, `USNUM`)
  - `Sanitizer.cs` — `AnnotationProcessor` with `Sanitize` / `Validate` implementations
  - `FieldResults.cs` — result model
  - `Program.cs` — demo runner
- Design choices:
  - Simple, explicit annotation names for clarity in POC
  - Handler-based or hashmap registry approach is next step for scaling

_Speaker note:_ Potential next steps: registry of handlers, masking, role-based redaction (flag for can't be shown at all), hash map to hold handlers, everythingin one call, app can change flags to turn on steps.

---

## Business Benefits & Ask

- Benefits:
  - Reduces likelihood of SQL/XSS from non-HTTP inputs
  - Standardizes sanitization / masking across apps
  - Low developer friction — annotate fields; reuse handlers; get updates as requirements change
- Ask / Request for Pilot Approval:
  1. Approve a pilot using annotations in one app
  2. Allocate 1-2 devs for implementation + 1 security SME for review
  3. Decide success criteria (reduction in high/critical findings, dev effort/time-to-fix)

_Speaker note:_ Provide rough estimate: small POC integration ~2-3 dev-days, pilot ~4–6 dev-weeks depending on scope.

---

## Next Steps / Roadmap

- Short-term (this quarter)
  - Pilot in one service, collect metrics, gather developer feedback
  - Add a handler registry and masking support (role-based)
- Mid-term
  - CI integration to surface missing annotations or inconsistent field handling
  - Developer docs, code snippets, and template PRs for common fixes
- Long-term
  - Expand to library/reusable package, integrate with SCA/scan workflows

---

## Appendix: Quick sample code (Sanitize / Validate)

```csharp
// Example annotation usage
public class DemoData {
  [TIN] public string SSN = "123-45-6789";
  [PAN] public string Card = "4111 1111 1111 1111";
}

// Call from demo
var san = AnnotationProcessor.Sanitize(demo);
var val = AnnotationProcessor.Validate(demo);
```

_Speaker note:_ Point managers to `README.md` and full repo if they want to see the working demo.

---

*File created: `docs/presentation.md`. Edit this file in the repo; when ready I can export to PPTX or generate slides for VS Code/Reveal.*
  </script>

  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/reveal.js@4.5.0/dist/reveal.js"></script>
  <script>
    // Build slides from embedded markdown
    (function(){
      const md = document.getElementById('md-source').textContent || '';
      // split on lines containing only --- (allow surrounding whitespace)
      const slides = md.split(/\r?\n---\r?\n/);
      const slidesEl = document.getElementById('slides');
      slides.forEach(s => {
        // extract speaker notes pattern: _Speaker note:_
        const idx = s.indexOf('\n_Speaker note:_');
        let main = s;
        let notes = null;
        if (idx !== -1) {
          main = s.substring(0, idx);
          notes = s.substring(idx + 1).replace(/_Speaker note:_\s*/i, '');
        }
        const section = document.createElement('section');
        section.innerHTML = marked.parse(main);
        if (notes) {
          const aside = document.createElement('aside');
          aside.className = 'notes';
          aside.innerHTML = marked.parse(notes);
          section.appendChild(aside);
        }
        slidesEl.appendChild(section);
      });

      // initialize Reveal
      Reveal.initialize({
        hash: true,
        slideNumber: true,
        plugins: []
      });
    })();
  </script>
</body>
</html>
